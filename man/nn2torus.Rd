% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nn_wrap.R
\name{nn2torus}
\alias{nn2torus}
\title{Nearest Neighbour Search}
\usage{
nn2torus(data, query = data, k = min(10, nrow(data)),
  treetype = c("kd", "bd"), searchtype = c("standard", "priority",
  "radius"), radius = 0, eps = 0, torus, ranges)
}
\arguments{
\item{data}{An \bold{M} x \bold{d} data.frame or matrix, where each of the 
\bold{M} rows is a point or a (column) vector (where \bold{d=1}).}

\item{query}{A set of \bold{N} x \bold{d} points that will be queried against 
\code{data}. \bold{d}, the number of columns, must be the same as 
\code{data}. If missing, defaults to \code{data}.}

\item{k}{The maximum number of nearest neighbours to compute. The default 
value is set to the smaller of the number of columnns in data}

\item{treetype}{Character vector specifying the standard \code{'kd'} tree or a
\code{'bd'} (box-decomposition, AMNSW98) tree which may perform better for 
larger point sets}

\item{searchtype}{See details}

\item{radius}{Radius of search for searchtype='radius'}

\item{eps}{Error bound: default of 0.0 implies exact nearest neighbour search}

\item{torus}{An integer vector with element in
\{1, ..., \code{ncol(data)}\}.  If \code{torus} is missing then
a call to \code{nn2torus} is equivalent to a call to
\code{\link[RANN]{nn2}}.}

\item{ranges}{A \code{length(torus)} by \code{2} numeric matrix.
If \code{length(torus)}=2 then \code{ranges} may be a vector of length 2.
Row \code{i} gives the range of variation of the variable indexed by
\code{torus[i]}. \code{ranges[i, 1]} and \code{ranges[i, 2]}
are equivalent values of the variable, such as 0 degrees and 360 degrees.}
}
\value{
Return
}
\description{
Uses \code{\link[RANN]{nn2}} to find the nearest neighbours in a dataset
specified points, adding the option to wrap certain variables on a torus.
}
\details{
Add details
}
\examples{
set.seed(20092019)
# Example from the RANN:nn2 documentation
x1 <- runif(100, 0, 2*pi)
x2 <- runif(100, 0, 3)
DATA <- data.frame(x1, x2)
nearest <- nn2torus(DATA, DATA)

# Now suppose that x1 is should be wrapped
ranges <- matrix(c(0, 2 * pi), 1, 2)
nearest <- nn2torus(DATA, DATA, torus = 1, ranges = ranges)
edge <- matrix(c(2 * pi, 1.5), 1, 2)
res <- nn2torus(DATA, edge, torus = 1, ranges = ranges)
plot(res, pch = 16)

y <- nshs[, "hs"]
x <- nshs[, c("season", "direction")]
query <- matrix(c(350, 0, 150, 360), 2, 2)
ranges <- matrix(c(0, 0, 360, 360), 2, 2)
res <- nn2torus(data = x, query = query, k = 100, torus = 1:2,
                ranges = ranges)
plot(res)
}
\seealso{
\code{\link[RANN]{nn2}}: nearest neigbour search.
}
