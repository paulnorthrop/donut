% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nn_wrap.R
\name{nnt}
\alias{nnt}
\title{Nearest Neighbour Search}
\usage{
nnt(data, query = data, k = min(10, nrow(data)), torus, ranges,
  package = c("RANN", "RANN.L1", "nabor"), method = 1, ...)
}
\arguments{
\item{data}{An \eqn{M} by \eqn{d} numeric matrix or data frame.  Each of the
\eqn{M} rows contains a \eqn{d}-dimensional observation.}

\item{query}{An \eqn{N} by \eqn{d} numeric matrix or data frame.  Each row
contains an \eqn{d}-dimensional point that will be queried against
\code{data}.}

\item{k}{An integer scalar.  The number of nearest neighbours, of the
points in the rows of \code{query}, to find.}

\item{torus}{An integer vector with element in
\{1, ..., \code{ncol(data)}\}.  If \code{torus} is missing then
a call to \code{nnt} is equivalent to a call to the function chosen
by \code{package}.}

\item{ranges}{A \code{length(torus)} by \code{2} numeric matrix.
Row \code{i} gives the range of variation of the variable indexed by
\code{torus[i]}. \code{ranges[i, 1]} and \code{ranges[i, 2]}
are equivalent values of the variable, such as 0 degrees and 360 degrees.
If \code{length(torus)} = 2 then \code{ranges} may be a vector of length
2.}

\item{package}{The package to use calculate the nearest neighbours.
One of \code{"RANN"}, \code{"RANN.L1"} or \code{"nabor"}.}

\item{method}{An integer scalar, equal to 1 or 2.}

\item{...}{Further arguments to be passed to
\code{\link[RANN:nn2]{RANN::nn2}},
\code{\link[RANN.L1:nn2]{RANN.L1::nn2}} or
\code{\link[nabor:knn]{nabor::knn}}}
}
\value{
Return
}
\description{
Uses \code{\link[RANN]{nn2}} to find the nearest neighbours in a dataset
specified points, adding the option to wrap certain variables on a torus.
}
\details{
Add details
}
\examples{
set.seed(20092019)
# Example from the RANN:nn2 documentation
x1 <- runif(100, 0, 2 * pi)
x2 <- runif(100, 0, 3)
DATA <- data.frame(x1, x2)
nearest <- nnt(DATA, DATA)

# Suppose that x1 should be wrapped
ranges <- c(0, 2 * pi)
nearest <- nnt(DATA, DATA, torus = 1, ranges = ranges)
edge <- matrix(c(2 * pi, 1.5), 1, 2)
res <- nnt(DATA, edge, torus = 1, ranges = ranges)
plot(res, pch = 16)

# Suppose that x1 and x2 should be wrapped
ranges <- rbind(c(0, 2 * pi), c(0, 3))
nearest <- nnt(DATA, DATA[1, ], torus = 1:2, ranges = ranges)
edge <- rbind(c(2 * pi, 1.5), c(2 * pi, 3))
res <- nnt(DATA, edge, torus = 1:2, ranges = ranges)
plot(res, pch = 16)

y <- nshs[, "hs"]
x <- nshs[, c("season", "direction")]
query <- matrix(c(350, 0, 150, 360), 2, 2)
ranges <- matrix(c(0, 0, 360, 360), 2, 2)
res <- nnt(data = x, query = query, k = 100, torus = 1:2, ranges = ranges)
res <- nnt(data = x, query = as.matrix(x), k = 100, torus = 1:2, ranges = ranges)
plot(res)
}
\seealso{
\code{\link[RANN:nn2]{RANN::nn2}},
  \code{\link[RANN.L1:nn2]{RANN.L1::nn2}},
  \code{\link[nabor:knn]{nabor::knn}}: nearest neigbour searchess.
}
