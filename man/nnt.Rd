% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nn_wrap.R
\name{nnt}
\alias{nnt}
\title{Nearest Neighbour Search}
\usage{
nnt(data, query = data, k = min(10, nrow(data)), fn = RANN::nn2,
  torus, ranges, method = 1, ...)
}
\arguments{
\item{data}{An \eqn{M} by \eqn{d} numeric matrix or data frame.  Each of the
\eqn{M} rows contains a \eqn{d}-dimensional observation.}

\item{query}{An \eqn{N} by \eqn{d} numeric matrix or data frame.  Each row
contains an \eqn{d}-dimensional point that will be queried against
\code{data}.}

\item{k}{An integer scalar.  The number of nearest neighbours, of the
points in the rows of \code{query}, to find.}

\item{fn}{The function with which to calculate the nearest neighbours.
The syntax of this function must be \code{fn(data, query, k, ...)}.
The default is \code{RANN::nn2}.  Other possibilities are
\code{RANN.L1:nn2} and \code{nabor::knn}.}

\item{torus}{An integer vector with element in
\{1, ..., \code{ncol(data)}\}.}

\item{ranges}{A \code{length(torus)} by \code{2} numeric matrix.
Row \code{i} gives the range of variation of the variable indexed by
\code{torus[i]}. \code{ranges[i, 1]} and \code{ranges[i, 2]}
are equivalent values of the variable, such as 0 degrees and 360 degrees.
If \code{length(torus)} = 1 then \code{ranges} may be a vector of length
2.}

\item{method}{An integer scalar, equal to 1 or 2.  See \strong{Details}.}

\item{...}{Further arguments to be passed to \code{fn}.}
}
\value{
An object (a list) of class \code{"nnt"} containing the following
  components.
  \item{nn.idx}{An \eqn{N} by \eqn{d} integer matrix of the \code{k}
    nearest neighbour indices, i.e. the rows of \code{data}.}
  \item{nn.dists}{An \eqn{N} by \eqn{d} numeric matrix of the \code{k}
    nearest neighbour distances.}
  \item{data, query, k}{The input arguments \code{data}, \code{query} and
    \code{k}.}
  \item{call}{The call to \code{spm}.}
}
\description{
Uses a user-supplied function to find the \code{k} nearest neighbours of
specified points in a dataset, adding the option to wrap certain variables
on a torus.
}
\details{
If \code{method = 1} then the data are partially replicated, arranged
  around the original data in a way that wraps the variables in \code{torus} on their respective
  ranges in \code{ranges}.  Then \code{fn} is called using this replicated
  dataset as the argument \code{data}.  If \code{method = 2} then the
  following approach is used for the point in each row in \code{query}.
  The data indexed by \code{torus} are shifted (and wrapped) so that the
  point is located at the respective midpoints of \code{ranges}.
  This is only be an efficient approach if the number of points in
  \code{query} are is small.

  If \code{torus} is missing then \code{fn} is called using
  \code{fn(data = data, query = query, k = k, ...)}, so that a call to
  \code{nnt} is equivalent to a call to the function chosen by \code{fn}.
}
\examples{
set.seed(20092019)
x1 <- c(0.2, 0.9)
x2 <- c(0.4, 0.7)
x <- cbind(x1, x2)
edge <- x
res <- nnt(x, edge)
ranges <- c(0, 1)
res <- nnt(x, edge, torus = 1, ranges = ranges)

# Example from the RANN:nn2 documentation
x1 <- runif(100, 0, 2 * pi)
x2 <- runif(100, 0, 3)
DATA <- data.frame(x1, x2)
nearest <- nnt(DATA, DATA)

# Suppose that x1 should be wrapped
ranges <- c(0, 2 * pi)
nearest <- nnt(DATA, DATA, torus = 1, ranges = ranges)
edge <- matrix(c(2 * pi, 1.5), 1, 2)
res <- nnt(DATA, edge, torus = 1, ranges = ranges)
plot(res, pch = 16)

# Suppose that x1 and x2 should be wrapped
ranges <- rbind(c(0, 2 * pi), c(0, 3))
nearest <- nnt(DATA, DATA[1, ], torus = 1:2, ranges = ranges)
edge <- rbind(c(2 * pi, 1.5), c(2 * pi, 3))
res <- nnt(DATA, edge, torus = 1:2, ranges = ranges)
plot(res, pch = 16)

n <- 100
pjn <- cbind(runif(n, 0, 2), runif(n, 0, 1))
ranges <- rbind(c(0, 2), c(0, 1))
edge <- rbind(c(1.0, 0.5), c(0.1, 0.1))
res <- nnt(pjn, edge, torus = 1:2, ranges = ranges, method = 2)
plot(res, pch = 16)

y <- nshs[, "hs"]
x <- nshs[, c("season", "direction")]
query <- matrix(c(350, 0, 150, 360), 2, 2)
ranges <- matrix(c(0, 0, 360, 360), 2, 2)
res <- nnt(data = x, query = query, k = 100, torus = 1:2, ranges = ranges)
res <- nnt(data = x, query = as.matrix(x), k = 100, torus = 1:2, ranges = ranges)
plot(res)

which_vals <- 1:5
y <- nshs[which_vals, "hs"]
x <- nshs[which_vals, c("season", "direction")]
query <- matrix(c(350, 0, 150, 360), 2, 2)
ranges <- matrix(c(0, 0, 360, 360), 2, 2)
res <- nnt(data = x, query = query, k = 2, torus = 1:2, ranges = ranges)
}
\seealso{
\code{\link[RANN:nn2]{RANN::nn2}},
  \code{\link[RANN.L1:nn2]{RANN.L1::nn2}},
  \code{\link[nabor:knn]{nabor::knn}}: nearest neigbour searches.
}
